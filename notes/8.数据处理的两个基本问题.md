# 王爽汇编第八章,数据处理的两个基本问题
[toc]
本章对前面的所有内容是具有总结性的。我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：

- (1) 处理的数据在什么地方？
- (2)要处理的数据有多长？

`这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。`

## bx、si、di和bp

- 在8086CPU中，只有这4个寄存器可以用在`[...]`中进行内存单元的寻址。
- 在[...]中，这4个寄存器可以单个出现，或只能以4种组合出现：`bx和si`、`bx和di`、`bp和si`、`bp和di`。
- 只要在[...]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中。

![image-20210918101009157](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918101011467-323827835.png) 

## 机器指令处理的数据在什么地方

数据处理指令大致分为3类：`读取`、`写入`、`运算`。

在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：`CPU内部、内存、端口`

![image-20210918102112560](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918102114390-123667518.png) 

## 汇编语言中数据位置的表达

汇编语言中用3个概念来表达数据的位置。

- 立即数(idata)

![image-20210918102837418](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918102838771-380510044.png)  

- 寄存器

![image-20210918102606296](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918102607657-379524307.png) 

- 段地址(SA)和偏移地址(EA)

![image-20210918103358879](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918103400703-650540820.png) 

## 寻址方式

当数据存在内存中的时候，可以用多种方式来给定内存单元的偏移地址，这种定位内存单元的方法一般称为`寻址方式`。

![image-20210918103524663](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918103526866-4683537.png) 

## 指令要处理的数据有多长

`8086CPU`的指令，可以处理两种尺寸的数据，byte和word

- 通过寄存器名指明要处理的数据的尺寸。

例如： `mov al, ds:[0]` 寄存器al指明了数据为1字节

- 在没有寄存器名存在的情况下，用操作符`X ptr`指明内存单元的长度，X在汇编指令中可以为`word`或`byte`。

例如：`mov byte ptr ds:[0], 1` byte ptr 指明了指令访问的内存单元是一个字节单元

- 有些指令默认了访问的是字单元还是字节单元

例如，`push [1000H]`，push 指令只进行字操作。



插播一点`x86`的知识，在X86架构中一般会见到下面汇编指令

`xxx dword ptr xxx`，这种就是指明是长度是4字节,也是Win中C++的`DWORD`类型`unsigned long`。

## 寻址方式的综合应用

![image-20210918104600229](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918104602641-276796017.png) 

汇编代码：

![image-20210918105140421](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918105142154-2143121732.png) 

c语言代码：

```c++
/*定义一个公司记录的结构体*/
struct company
{
    char cn[3];/*公司名称*/
    char hn[9];/*总裁姓名*/
    int pm;/*排名*/
    int sr;/*收入*/
    char cp[3];/*著名产品*/
};

int main()
{
    /*定义一个公司记录的变量,内存中将存有一条公司的记录*/
    struct company dec = {"DEC","Ken Olsen",137,40,"PDP"};
    
    int i;
    dec.pm = 38;
    dec.sr = dec.sr + 70;
    
    i = 0;
    dec.cp[i] = 'V';
    i++;
    dec.cp[i] = 'A';
    i++;
    dec.cp[i] = 'X';
    
    return 0;
}
```

## dd、dup、mul、div指令

### dd 伪指令

db和dw定义字节型数据和字型数据。

dd用来定义dword (double word,双字) 4字节类型数据的伪指令

### dup操作符

dup在汇编中同db、dw、dd等一样，也是由编译器识别处理的符号。

它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复。

![image-20210918110954347](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918110956171-1832116408.png) 

### mul乘法指令

mul乘法指令，之前在介绍寄存器章节的时候有提到过，会将结果保存在ax中。

注意：(8086中使用mul做乘法的时候：相乘的两个数：要么都是8位，要么都是16位)。

- 8位：`AL`中和`8位寄存器`或`内存字节单元`中;
- 16位：`AX`中和`16位寄存器`或`内存字节单元`中。

结果：

- 8位：AX中；
- 16位：DX(高位)和AX(低位)中。

![image-20210918131204039](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918131205610-492496697.png) 

### div除法指令

- 除数：有8位和16位两种，在一个寄存器或内存单元中。

- 被除数：默认放在AX或DX和AX中，
  如果除数为8位，被除数则为16位，默认在AX中存放；
  如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。

- 结果：
  如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；
  如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。

![image-20210918131346768](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210918131348036-781882083.png) 



> 参考文献：
> https://blog.csdn.net/qq_39654127/article/details/88698911 (CSDN王爽《汇编语言》笔记)
> 《王爽汇编语言第4版 第8章》
